name: Build Linux Packages

on:
  push:
    branches:
      - main
      - dev
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write

env:
  NODE_VERSION: "22"
  RUST_VERSION: "stable"

jobs:
  build-deb-rpm-appimage:
    # Build in Debian 12 container for GLIBC 2.36 compatibility
    runs-on: ubuntu-latest
    container:
      image: debian:12
    timeout-minutes: 90
    defaults:
      run:
        shell: bash

    steps:
      - name: Install git and dependencies
        shell: sh
        run: |
          apt-get update
          apt-get install -y \
            bash \
            git \
            curl \
            wget \
            build-essential \
            file \
            pkg-config \
            libssl-dev \
            libwebkit2gtk-4.1-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libsoup-3.0-dev \
            patchelf \
            fuse \
            libfuse2 \
            python3 \
            ca-certificates \
            libvips-dev \
            libcairo2-dev \
            libpango1.0-dev \
            libjpeg-dev \
            libgif-dev

          # Install Node.js 22 (needed for setup-node action to run)
          curl -fsSL https://deb.nodesource.com/setup_22.x | bash -
          apt-get install -y nodejs

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust via rustup (inside container for GLIBC compatibility)
        run: |
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
          . "$HOME/.cargo/env"
          rustc --version
          cargo --version

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Sync version from package.json
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "Building version: $VERSION"
          sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json
          sed -i "0,/^version = \"[^\"]*\"/s//version = \"$VERSION\"/" src-tauri/Cargo.toml
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Clone and patch WebClients
        run: |
          set -euo pipefail

          # Check if we need to clone or update WebClients
          REMOTE_COMMIT=$(git ls-remote https://github.com/ProtonMail/WebClients.git refs/heads/main | cut -f1)
          LOCAL_COMMIT=""

          if [ -d "WebClients/.git" ]; then
            LOCAL_COMMIT=$(git -C WebClients rev-parse HEAD 2>/dev/null || echo "")
          fi

          if [ "$LOCAL_COMMIT" = "$REMOTE_COMMIT" ] && [ -n "$LOCAL_COMMIT" ]; then
            echo "‚úÖ WebClients is up-to-date (commit: ${LOCAL_COMMIT:0:8}), skipping clone"
          else
            echo "üì• Cloning WebClients (remote: ${REMOTE_COMMIT:0:8}, local: ${LOCAL_COMMIT:0:8:-none})"
            rm -rf WebClients .git/modules/WebClients 2>/dev/null || true
            git clean -fdx WebClients 2>/dev/null || true
            git clone --depth=1 --single-branch --branch main \
              https://github.com/ProtonMail/WebClients.git WebClients
          fi

          echo "üîß Patching dependencies and configuring Yarn..."
          python3 scripts/fix_deps.py

          # Create empty yarn.lock to mark WebClients as separate project (prevents workspace detection issues)
          : > WebClients/yarn.lock

      - name: Build WebClients (Proton Drive)
        run: |
          set -euo pipefail

          mv ./package.json ./package.json.bak 2>/dev/null || true
          mv ./yarn.lock ./yarn.lock.bak 2>/dev/null || true

          cd WebClients

          echo "üì¶ Installing WebClients dependencies..."
          export NODE_OPTIONS="--max-old-space-size=8192"
          node .yarn/releases/yarn-4.12.0.cjs install --network-timeout 900000

          cd ..
          mv ./package.json.bak ./package.json 2>/dev/null || true
          mv ./yarn.lock.bak ./yarn.lock 2>/dev/null || true

          echo "üì¶ Creating stubs for private packages..."
          python3 scripts/create_stubs.py

          cd WebClients

          echo "üî® Building Proton Drive web app..."
          node .yarn/releases/yarn-4.12.0.cjs workspace proton-drive build:web

          echo "üî® Building Account app for SSO..."
          node .yarn/releases/yarn-4.12.0.cjs workspace proton-account build:web || echo "Account build failed"

          echo "üî® Building Verify app for captcha..."
          node .yarn/releases/yarn-4.12.0.cjs workspace proton-verify build:web || echo "Verify build optional"

          echo "üì¶ Copying account app to drive dist..."
          if [ -d "applications/account/dist" ]; then
            cp -r applications/account/dist applications/drive/dist/account
            echo "üîß Fixing account app paths for nested deployment..."
            # Fix base href and asset paths in account app HTML files
            find applications/drive/dist/account -name "*.html" -exec sed -i \
              -e 's|<base href="/">|<base href="/account/">|g' \
              -e 's|href="/assets/|href="/account/assets/|g' \
              -e 's|src="/assets/|src="/account/assets/|g' \
              -e 's|content="/assets/|content="/account/assets/|g' {} \;
            # Fix asset paths in JavaScript files (runtime chunks reference other chunks)
            find applications/drive/dist/account -name "*.js" -exec sed -i \
              -e 's|"assets/static/|"/account/assets/static/|g' \
              -e 's|"/assets/static/|"/account/assets/static/|g' {} \;
            echo "‚úÖ Account app copied and paths fixed"
          fi

          echo "üì¶ Copying verify app to drive dist..."
          if [ -d "applications/verify/dist" ]; then
            cp -r applications/verify/dist applications/drive/dist/verify
            echo "üîß Fixing verify app paths for nested deployment..."
            # Fix base href and asset paths in verify app HTML files
            find applications/drive/dist/verify -name "*.html" -exec sed -i \
              -e 's|<base href="/">|<base href="/verify/">|g' \
              -e 's|href="/assets/|href="/verify/assets/|g' \
              -e 's|src="/assets/|src="/verify/assets/|g' \
              -e 's|content="/assets/|content="/verify/assets/|g' {} \;
            # Fix asset paths in JavaScript files
            find applications/drive/dist/verify -name "*.js" -exec sed -i \
              -e 's|"assets/static/|"/verify/assets/static/|g' \
              -e 's|"/assets/static/|"/verify/assets/static/|g' {} \;
            echo "‚úÖ Verify app copied and paths fixed"
          fi

          echo "üîç Verifying build output..."
          if [ ! -d "applications/drive/dist" ]; then
            echo "‚ùå CRITICAL: dist directory not found!"
            exit 1
          fi

          if [ ! -f "applications/drive/dist/index.html" ]; then
            echo "‚ùå CRITICAL: index.html not found in dist!"
            echo "Contents of applications/drive/:"
            ls -la applications/drive/ || true
            exit 1
          fi

          echo "‚úÖ WebClients build verification passed"
          echo "üì¶ Dist contents:"
          ls -lah applications/drive/dist/ | head -20
          
          FILE_COUNT=$(find applications/drive/dist -type f | wc -l)
          echo "üìä Total files in dist: $FILE_COUNT"
          
          if [ "$FILE_COUNT" -lt 5 ]; then
            echo "‚ùå CRITICAL: Too few files in dist directory!"
            exit 1
          fi

          cd ..

      - name: Verify dist path from project root
        run: |
          echo "üîç Verifying dist path that Tauri will use..."
          DIST_PATH="WebClients/applications/drive/dist"

          if [ ! -d "$DIST_PATH" ]; then
            echo "‚ùå CRITICAL: $DIST_PATH not found from project root!"
            echo "Current directory:"
            pwd
            echo "Directory structure:"
            ls -la
            exit 1
          fi

          if [ ! -f "$DIST_PATH/index.html" ]; then
            echo "‚ùå CRITICAL: $DIST_PATH/index.html not found!"
            exit 1
          fi

          # CRITICAL: Verify account app paths are correctly prefixed
          # This prevents white screen issues in packaged apps
          if [ -f "$DIST_PATH/account/index.html" ]; then
            echo "üîç Verifying account app asset paths..."
            if grep -q 'src="/assets/' "$DIST_PATH/account/index.html"; then
              echo "‚ùå CRITICAL: Account app has unfixed asset paths!"
              echo "   Found: src=\"/assets/\" (should be src=\"/account/assets/\")"
              echo "   This will cause white screen in packaged apps!"
              exit 1
            fi
            if grep -q 'href="/assets/' "$DIST_PATH/account/index.html"; then
              echo "‚ùå CRITICAL: Account app has unfixed href paths!"
              exit 1
            fi
            if ! grep -q '<base href="/account/">' "$DIST_PATH/account/index.html"; then
              echo "‚ùå CRITICAL: Account app missing correct base href!"
              exit 1
            fi
            echo "‚úÖ Account app paths verified"
          fi

          # Verify verify app paths
          if [ -f "$DIST_PATH/verify/index.html" ]; then
            echo "üîç Verifying verify app asset paths..."
            if grep -q 'src="/assets/' "$DIST_PATH/verify/index.html"; then
              echo "‚ùå CRITICAL: Verify app has unfixed asset paths!"
              exit 1
            fi
            echo "‚úÖ Verify app paths verified"
          fi

          echo "‚úÖ Dist path verified from project root"
          echo "Full path: $(pwd)/$DIST_PATH"

      - name: Install Tauri dependencies
        run: npm install

      - name: Prepare desktop file for bundlers
        run: |
          # Desktop file already exists in repo at src-tauri/linux/com.proton.drive.desktop
          # Create a copy with the binary name for Tauri bundler compatibility
          cp src-tauri/linux/com.proton.drive.desktop src-tauri/linux/proton-drive.desktop
          echo "Desktop files ready"
          cat src-tauri/linux/com.proton.drive.desktop

      - name: Build DEB and RPM only (skip AppImage for now)
        run: |
          echo "üî® Building DEB and RPM packages..."
          npx tauri build --bundles deb,rpm --verbose

          echo "‚úÖ DEB and RPM build complete"

          # Rename RPM from Proton.Drive to proton-drive
          echo "üîß Renaming RPM package..."
          cd src-tauri/target/release/bundle/rpm
          for f in Proton.Drive*.rpm; do
            if [ -f "$f" ]; then
              newname=$(echo "$f" | sed 's/Proton\.Drive/proton-drive/g')
              mv "$f" "$newname"
              echo "Renamed: $f -> $newname"
            fi
          done
          cd -

          # Fix icon names in packages - Tauri uses productName but we need identifier
          echo "üîß Checking icon naming in packages..."
          # Note: The DEB/RPM packages are already built, icons are embedded
          # The desktop file uses Icon=com.proton.drive which requires icons to be
          # installed as com.proton.drive.{png,svg} in hicolor directories

          find src-tauri/target/release/bundle -type f \
            \( -name "*.deb" -o -name "*.rpm" \) -ls

      - name: Verify GLIBC compatibility
        run: |
          echo "üîç Checking GLIBC requirements of built binary..."
          BINARY="src-tauri/target/release/proton-drive"

          # Check required GLIBC version
          GLIBC_VERSIONS=$(objdump -T "$BINARY" 2>/dev/null | grep GLIBC | sed 's/.*GLIBC_//' | cut -d' ' -f1 | sort -V | uniq)
          echo "Required GLIBC versions:"
          echo "$GLIBC_VERSIONS"

          # Get the highest required version
          MAX_GLIBC=$(echo "$GLIBC_VERSIONS" | tail -1)
          echo "Highest required GLIBC: $MAX_GLIBC"

          # Debian 12 has GLIBC 2.36, so we need to ensure we don't require higher
          if printf '%s\n' "2.36" "$MAX_GLIBC" | sort -V | head -1 | grep -q "2.36"; then
            if [ "$MAX_GLIBC" = "2.36" ] || printf '%s\n' "$MAX_GLIBC" "2.36" | sort -V | head -1 | grep -q "$MAX_GLIBC"; then
              echo "‚úÖ Binary is compatible with Debian 12 (GLIBC 2.36)"
            else
              echo "‚ùå Binary requires GLIBC $MAX_GLIBC which is higher than Debian 12's 2.36"
              exit 1
            fi
          else
            echo "‚úÖ Binary is compatible with GLIBC 2.36"
          fi

      - name: Build AppImage manually (workaround for linuxdeploy issues)
        run: |
          set -euo pipefail
          
          echo "üî® Building AppImage manually..."
          
          VERSION=$(node -p "require('./package.json').version")
          BINARY_PATH="src-tauri/target/release/proton-drive"
          APPDIR="AppDir"
          
          # Verify binary exists
          if [ ! -f "$BINARY_PATH" ]; then
            echo "‚ùå Binary not found at $BINARY_PATH"
            exit 1
          fi
          
          # Create AppDir structure
          mkdir -p "$APPDIR/usr/bin"
          mkdir -p "$APPDIR/usr/share/applications"
          mkdir -p "$APPDIR/usr/share/icons/hicolor/scalable/apps"
          mkdir -p "$APPDIR/usr/share/icons/hicolor/128x128/apps"
          mkdir -p "$APPDIR/usr/share/icons/hicolor/32x32/apps"
          mkdir -p "$APPDIR/usr/share/icons/hicolor/256x256/apps"
          
          # Copy binary
          cp "$BINARY_PATH" "$APPDIR/usr/bin/proton-drive"
          chmod +x "$APPDIR/usr/bin/proton-drive"
          
          # Copy desktop file with correct icon reference (use app identifier)
          cat > "$APPDIR/usr/share/applications/com.proton.drive.desktop" << 'EOF'
          [Desktop Entry]
          Version=1.0
          Type=Application
          Name=Proton Drive
          Comment=Secure cloud storage
          Exec=proton-drive %U
          Icon=com.proton.drive
          Categories=Utility;Network;FileTransfer;
          Keywords=proton;drive;cloud;storage;sync;
          Terminal=false
          StartupWMClass=proton-drive
          StartupNotify=true
          EOF

          # Copy icons with identifier-based naming for freedesktop compliance
          cp src-tauri/icons/proton-drive.svg "$APPDIR/usr/share/icons/hicolor/scalable/apps/com.proton.drive.svg"
          cp src-tauri/icons/128x128.png "$APPDIR/usr/share/icons/hicolor/128x128/apps/com.proton.drive.png"
          cp src-tauri/icons/32x32.png "$APPDIR/usr/share/icons/hicolor/32x32/apps/com.proton.drive.png"
          cp src-tauri/icons/128x128@2x.png "$APPDIR/usr/share/icons/hicolor/256x256/apps/com.proton.drive.png"

          # Create top-level desktop file and icon (required by AppImage)
          cp "$APPDIR/usr/share/applications/com.proton.drive.desktop" "$APPDIR/com.proton.drive.desktop"
          cp src-tauri/icons/proton-drive.svg "$APPDIR/com.proton.drive.svg"
          ln -sf usr/share/icons/hicolor/128x128/apps/com.proton.drive.png "$APPDIR/.DirIcon"
          
          # Create AppRun with environment fixes
          cat > "$APPDIR/AppRun" << 'APPRUN_EOF'
          #!/bin/bash
          # Fix WebKitGTK EGL/GPU issues on various Linux configurations
          export GDK_GL=disable
          export WEBKIT_DISABLE_DMABUF_RENDERER=1
          export WEBKIT_DISABLE_COMPOSITING_MODE=1
          export WEBKIT_FORCE_SANDBOX=0
          export LIBGL_ALWAYS_SOFTWARE=1
          export GSK_RENDERER=cairo

          HERE="$(dirname "$(readlink -f "${0}")")"
          export PATH="${HERE}/usr/bin:${PATH}"
          export LD_LIBRARY_PATH="${HERE}/usr/lib:${LD_LIBRARY_PATH}"
          
          exec "${HERE}/usr/bin/proton-drive" "$@"
          APPRUN_EOF
          chmod +x "$APPDIR/AppRun"
          
          # Download appimagetool and extract it (FUSE not available in containers)
          wget -q "https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage" -O appimagetool
          chmod +x appimagetool
          ./appimagetool --appimage-extract

          # Build AppImage using extracted appimagetool
          ARCH=x86_64 ./squashfs-root/AppRun "$APPDIR" "proton-drive_${VERSION}_amd64.AppImage"
          
          # Move to bundle directory
          mkdir -p src-tauri/target/release/bundle/appimage
          mv "proton-drive_${VERSION}_amd64.AppImage" src-tauri/target/release/bundle/appimage/
          
          # Cleanup
          rm -rf "$APPDIR" appimagetool squashfs-root
          
          echo "‚úÖ AppImage created successfully"
          ls -lh src-tauri/target/release/bundle/appimage/

      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-packages
          path: |
            src-tauri/target/release/bundle/appimage/*.AppImage
            src-tauri/target/release/bundle/deb/*.deb
            src-tauri/target/release/bundle/rpm/*.rpm
          if-no-files-found: error
          retention-days: 30